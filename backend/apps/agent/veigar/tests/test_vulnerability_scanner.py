"""
Tests for the Veigar vulnerability scanner.

This module contains tests for the vulnerability scanner component of the Veigar agent.
"""

import pytest
import os
from pathlib import Path
from unittest.mock import patch, MagicMock
import json
import random

import sys
import os
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../..')))
from veigar.tools.vulnerability_scanner import VulnerabilityScanner


class TestVulnerabilityScanner:
    """Test suite for the VulnerabilityScanner class."""

    def setup_method(self):
        """Set up test environment before each test method."""
        self.scanner = VulnerabilityScanner()
        self.test_files = [
            "/path/to/file1.js",
            "/path/to/file2.py",
            "/path/to/Dockerfile",
            "/path/to/package.json",
            "/path/to/requirements.txt",
            "/path/to/index.html"
        ]
        self.test_repo = "test-repo"
        self.test_branch = "main"

    def test_initialization(self):
        """Test that the scanner initializes correctly with expected scanners."""
        assert len(self.scanner.scanners) > 0
        assert isinstance(self.scanner.scanners, list)
        
        scanner_names = [s["name"] for s in self.scanner.scanners]
        required_scanners = ["owasp-zap", "snyk", "trivy", "dependency-check", "grype", "nuclei"]
        
        for scanner in required_scanners:
            assert scanner in scanner_names, f"Required scanner {scanner} not found"

    def test_get_scanners_for_depth(self):
        """Test that the correct scanners are returned for different scan depths."""
        basic_scanners = self.scanner._get_scanners_for_depth("basic")
        standard_scanners = self.scanner._get_scanners_for_depth("standard")
        deep_scanners = self.scanner._get_scanners_for_depth("deep")
        
        assert all(s["type"] == "dependency" for s in basic_scanners)
        
        assert all(s["type"] in ["dependency", "container"] for s in standard_scanners)
        
        assert len(deep_scanners) >= len(standard_scanners)
        
        unknown_scanners = self.scanner._get_scanners_for_depth("unknown")
        assert len(unknown_scanners) == len(standard_scanners)

    @patch("subprocess.run")
    def test_run_trivy_scan_with_tool_available(self, mock_run):
        """Test Trivy scanning when the tool is available."""
        mock_process = MagicMock()
        mock_process.stdout = json.dumps({
            "Results": [
                {
                    "Vulnerabilities": [
                        {
                            "VulnerabilityID": "CVE-2021-44228",
                            "Title": "Log4Shell",
                            "Description": "Remote code execution in Log4j",
                            "Severity": "CRITICAL",
                            "PkgName": "log4j-core",
                            "InstalledVersion": "2.14.0",
                            "FixedVersion": "2.15.0",
                            "CweIDs": ["CWE-502"]
                        }
                    ]
                }
            ]
        })
        mock_process.returncode = 0
        mock_run.return_value = mock_process
        
        results = self.scanner._run_trivy_scan(["/path/to/Dockerfile"])
        
        assert len(results) == 1
        assert results[0]["title"] == "Log4Shell"
        assert results[0]["severity"] == "critical"
        assert results[0]["cve"] == "CVE-2021-44228"
        assert "log4j-core" in results[0]["package"]

    @patch("subprocess.run")
    def test_run_trivy_scan_with_tool_unavailable(self, mock_run):
        """Test Trivy scanning when the tool is not available."""
        mock_run.side_effect = FileNotFoundError("No such file or directory: 'trivy'")
        
        with patch.object(self.scanner, '_simulate_trivy_fallback') as mock_fallback:
            mock_fallback.return_value = [{"title": "Simulated vulnerability"}]
            results = self.scanner._run_trivy_scan(["/path/to/Dockerfile"])
            
            mock_fallback.assert_called_once()
            assert results == [{"title": "Simulated vulnerability"}]

    @patch("subprocess.run")
    def test_run_grype_scan_with_tool_available(self, mock_run):
        """Test Grype scanning when the tool is available."""
        mock_process = MagicMock()
        mock_process.stdout = json.dumps({
            "matches": [
                {
                    "vulnerability": {
                        "id": "CVE-2022-0778",
                        "description": "Infinite loop vulnerability in OpenSSL",
                        "severity": "High",
                        "fix": {"versions": ["1.1.1n"]}
                    },
                    "artifact": {
                        "name": "openssl",
                        "version": "1.1.1m"
                    }
                }
            ]
        })
        mock_process.returncode = 0
        mock_run.return_value = mock_process
        
        results = self.scanner._run_grype_scan(["/path/to/package.json"])
        
        assert len(results) == 1
        assert results[0]["title"] == "CVE-2022-0778"
        assert results[0]["severity"] == "high"
        assert results[0]["cve"] == "CVE-2022-0778"
        assert "openssl" in results[0]["package"]

    @patch("subprocess.run")
    def test_run_osv_scan_with_tool_available(self, mock_run):
        """Test OSV scanning when the tool is available."""
        mock_process = MagicMock()
        mock_process.stdout = json.dumps({
            "results": [
                {
                    "vulnerabilities": [
                        {
                            "id": "GHSA-xvch-5gv4-984h",
                            "summary": "Prototype pollution in minimist",
                            "aliases": ["CVE-2020-7598"],
                            "severity": [{"score": 7.5}],
                            "package": {
                                "name": "minimist",
                                "version": "1.2.5"
                            },
                            "fixed": ["1.2.6"]
                        }
                    ]
                }
            ]
        })
        mock_process.returncode = 0
        mock_run.return_value = mock_process
        
        results = self.scanner._run_osv_scan(["/path/to/package.json"])
        
        assert len(results) == 1
        assert results[0]["title"] == "GHSA-xvch-5gv4-984h"
        assert results[0]["severity"] == "high"
        assert results[0]["cve"] == "CVE-2020-7598"
        assert "minimist" in results[0]["package"]

    def test_deduplicate_vulnerabilities(self):
        """Test that vulnerabilities are properly deduplicated."""
        vulnerabilities = [
            {
                "file": "file1.js",
                "title": "XSS Vulnerability",
                "cve": "CVE-2021-1234"
            },
            {
                "file": "file1.js",
                "title": "XSS Vulnerability",
                "cve": "CVE-2021-1234"
            },
            {
                "file": "file2.js",
                "title": "XSS Vulnerability",
                "cve": "CVE-2021-1234"
            },
            {
                "file": "file1.js",
                "title": "Different Vulnerability",
                "cve": "CVE-2021-5678"
            }
        ]
        
        deduplicated = self.scanner._deduplicate_vulnerabilities(vulnerabilities)
        
        assert len(deduplicated) == 3
        
        unique_keys = set()
        for vuln in deduplicated:
            key = (vuln["file"], vuln["title"], vuln["cve"])
            unique_keys.add(key)
        
        assert len(unique_keys) == 3

    @patch.object(VulnerabilityScanner, "_run_scanner")
    def test_scan_integration(self, mock_run_scanner):
        """Test the full scan method with mocked scanner execution."""
        mock_run_scanner.return_value = [
            {
                "title": "Test Vulnerability 1",
                "severity": "high",
                "file": "file1.js"
            },
            {
                "title": "Test Vulnerability 2",
                "severity": "critical",
                "file": "file2.py"
            },
            {
                "title": "Test Vulnerability 3",
                "severity": "medium",
                "file": "file3.html"
            }
        ]
        
        results = self.scanner.scan(
            repository=self.test_repo,
            branch=self.test_branch,
            files=self.test_files,
            scan_depth="standard"
        )
        
        assert results["status"] == "success"
        assert results["repository"] == self.test_repo
        assert results["branch"] == self.test_branch
        assert results["scan_depth"] == "standard"
        assert len(results["vulnerabilities"]) == 3
        
        assert results["summary"]["total_vulnerabilities"] == 3
        assert results["summary"]["critical"] == 1
        assert results["summary"]["high"] == 1
        assert results["summary"]["medium"] == 1
        assert results["summary"]["low"] == 0
        assert results["summary"]["info"] == 0

    @patch.object(VulnerabilityScanner, "_run_scanner")
    def test_scan_with_error(self, mock_run_scanner):
        """Test scan handling when a scanner encounters an error."""
        mock_run_scanner.side_effect = Exception("Test scanner error")
        
        results = self.scanner.scan(
            repository=self.test_repo,
            branch=self.test_branch,
            files=self.test_files,
            scan_depth="basic"
        )
        
        assert results["status"] == "success"  # Overall scan should still succeed
        assert len(results["vulnerabilities"]) > 0
        
        error_vulns = [v for v in results["vulnerabilities"] if v.get("status") == "error"]
        assert len(error_vulns) > 0
        assert "error" in error_vulns[0]
