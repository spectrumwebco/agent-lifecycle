"""
Tests for the Veigar web vulnerability scanner.

This module contains tests for the web vulnerability scanner component of the Veigar agent.
"""

import pytest
import os
from pathlib import Path
from unittest.mock import patch, MagicMock
import json
import random

import sys
import os
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../..')))
from veigar.tools.web.web_vulnerability_scanner import WebVulnerabilityScanner


class TestWebVulnerabilityScanner:
    """Test suite for the WebVulnerabilityScanner class."""

    def setup_method(self):
        """Set up test environment before each test method."""
        self.scanner = WebVulnerabilityScanner()
        self.test_url = "https://example.com"
        self.test_endpoints = ["/api/users", "/api/products", "/login"]

    def test_initialization(self):
        """Test that the scanner initializes correctly."""
        assert hasattr(self.scanner, "scan_web_application")
        assert hasattr(self.scanner, "scan_api_endpoint")
        assert hasattr(self.scanner, "scan_authentication")

    @patch("requests.get")
    def test_check_url_accessibility(self, mock_get):
        """Test checking URL accessibility."""
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_get.return_value = mock_response
        
        result = self.scanner._check_url_accessibility(self.test_url)
        assert result is True
        
        mock_response.status_code = 404
        result = self.scanner._check_url_accessibility(self.test_url)
        assert result is False
        
        mock_get.side_effect = Exception("Connection error")
        result = self.scanner._check_url_accessibility(self.test_url)
        assert result is False

    @patch.object(WebVulnerabilityScanner, "_run_zap_scan")
    def test_scan_web_application(self, mock_run_zap_scan):
        """Test scanning a web application."""
        mock_run_zap_scan.return_value = [
            {
                "title": "XSS Vulnerability",
                "severity": "high",
                "url": f"{self.test_url}/login",
                "description": "Cross-site scripting vulnerability in login form",
                "remediation": "Implement proper input validation and output encoding"
            },
            {
                "title": "SQL Injection",
                "severity": "critical",
                "url": f"{self.test_url}/api/users",
                "description": "SQL injection vulnerability in user API",
                "remediation": "Use parameterized queries"
            }
        ]
        
        with patch.object(self.scanner, "_check_url_accessibility", return_value=True):
            results = self.scanner.scan_web_application(self.test_url)
            
            assert results["status"] == "success"
            assert results["url"] == self.test_url
            assert len(results["vulnerabilities"]) == 2
            assert results["vulnerabilities"][0]["title"] == "XSS Vulnerability"
            assert results["vulnerabilities"][1]["title"] == "SQL Injection"
            
            assert results["summary"]["total_vulnerabilities"] == 2
            assert results["summary"]["critical"] == 1
            assert results["summary"]["high"] == 1

    @patch.object(WebVulnerabilityScanner, "_run_zap_scan")
    def test_scan_web_application_inaccessible(self, mock_run_zap_scan):
        """Test scanning an inaccessible web application."""
        with patch.object(self.scanner, "_check_url_accessibility", return_value=False):
            results = self.scanner.scan_web_application(self.test_url)
            
            assert results["status"] == "error"
            assert "URL is not accessible" in results["error"]
            assert mock_run_zap_scan.call_count == 0

    @patch.object(WebVulnerabilityScanner, "_run_api_scan")
    def test_scan_api_endpoint(self, mock_run_api_scan):
        """Test scanning an API endpoint."""
        mock_run_api_scan.return_value = [
            {
                "title": "Missing Authentication",
                "severity": "high",
                "endpoint": f"{self.test_url}/api/users",
                "description": "API endpoint lacks proper authentication",
                "remediation": "Implement authentication for all API endpoints"
            },
            {
                "title": "Excessive Data Exposure",
                "severity": "medium",
                "endpoint": f"{self.test_url}/api/users",
                "description": "API returns sensitive user data",
                "remediation": "Filter sensitive data from API responses"
            }
        ]
        
        with patch.object(self.scanner, "_check_url_accessibility", return_value=True):
            results = self.scanner.scan_api_endpoint(f"{self.test_url}/api/users")
            
            assert results["status"] == "success"
            assert results["endpoint"] == f"{self.test_url}/api/users"
            assert len(results["vulnerabilities"]) == 2
            assert results["vulnerabilities"][0]["title"] == "Missing Authentication"
            assert results["vulnerabilities"][1]["title"] == "Excessive Data Exposure"
            
            assert results["summary"]["total_vulnerabilities"] == 2
            assert results["summary"]["high"] == 1
            assert results["summary"]["medium"] == 1

    @patch.object(WebVulnerabilityScanner, "_run_auth_scan")
    def test_scan_authentication(self, mock_run_auth_scan):
        """Test scanning authentication mechanisms."""
        mock_run_auth_scan.return_value = [
            {
                "title": "Weak Password Policy",
                "severity": "medium",
                "url": f"{self.test_url}/login",
                "description": "Password policy does not enforce strong passwords",
                "remediation": "Implement a strong password policy"
            },
            {
                "title": "Missing MFA",
                "severity": "high",
                "url": f"{self.test_url}/login",
                "description": "Multi-factor authentication is not implemented",
                "remediation": "Implement multi-factor authentication"
            },
            {
                "title": "Session Fixation",
                "severity": "high",
                "url": f"{self.test_url}/login",
                "description": "Session ID is not regenerated after login",
                "remediation": "Regenerate session ID after login"
            }
        ]
        
        with patch.object(self.scanner, "_check_url_accessibility", return_value=True):
            results = self.scanner.scan_authentication(f"{self.test_url}/login")
            
            assert results["status"] == "success"
            assert results["url"] == f"{self.test_url}/login"
            assert len(results["vulnerabilities"]) == 3
            assert results["vulnerabilities"][0]["title"] == "Weak Password Policy"
            assert results["vulnerabilities"][1]["title"] == "Missing MFA"
            assert results["vulnerabilities"][2]["title"] == "Session Fixation"
            
            assert results["summary"]["total_vulnerabilities"] == 3
            assert results["summary"]["high"] == 2
            assert results["summary"]["medium"] == 1

    @patch("subprocess.run")
    def test_run_zap_scan_with_tool_available(self, mock_run):
        """Test ZAP scanning when the tool is available."""
        mock_process = MagicMock()
        mock_process.stdout = json.dumps({
            "site": [
                {
                    "alerts": [
                        {
                            "name": "Cross Site Scripting (Reflected)",
                            "riskdesc": "High",
                            "desc": "XSS description",
                            "solution": "XSS solution",
                            "instances": [
                                {"uri": f"{self.test_url}/login"}
                            ]
                        }
                    ]
                }
            ]
        })
        mock_process.returncode = 0
        mock_run.return_value = mock_process
        
        results = self.scanner._run_zap_scan(self.test_url)
        
        assert len(results) == 1
        assert results[0]["title"] == "Cross Site Scripting (Reflected)"
        assert results[0]["severity"] == "high"
        assert results[0]["url"] == f"{self.test_url}/login"

    @patch("subprocess.run")
    def test_run_zap_scan_with_tool_unavailable(self, mock_run):
        """Test ZAP scanning when the tool is not available."""
        mock_run.side_effect = FileNotFoundError("No such file or directory: 'zap-cli'")
        
        with patch.object(self.scanner, '_simulate_zap_scan') as mock_fallback:
            mock_fallback.return_value = [{"title": "Simulated vulnerability"}]
            results = self.scanner._run_zap_scan(self.test_url)
            
            mock_fallback.assert_called_once()
            assert results == [{"title": "Simulated vulnerability"}]

    def test_generate_summary(self):
        """Test generating a summary of vulnerabilities."""
        vulnerabilities = [
            {"severity": "critical"},
            {"severity": "high"},
            {"severity": "high"},
            {"severity": "medium"},
            {"severity": "low"},
            {"severity": "info"}
        ]
        
        summary = self.scanner._generate_summary(vulnerabilities)
        
        assert summary["total_vulnerabilities"] == 6
        assert summary["critical"] == 1
        assert summary["high"] == 2
        assert summary["medium"] == 1
        assert summary["low"] == 1
        assert summary["info"] == 1

    @patch.object(WebVulnerabilityScanner, "scan_web_application")
    @patch.object(WebVulnerabilityScanner, "scan_api_endpoint")
    @patch.object(WebVulnerabilityScanner, "scan_authentication")
    def test_comprehensive_scan(self, mock_scan_auth, mock_scan_api, mock_scan_web):
        """Test comprehensive scanning of a web application."""
        mock_scan_web.return_value = {
            "status": "success",
            "vulnerabilities": [{"title": "Web Vulnerability"}],
            "summary": {"total_vulnerabilities": 1}
        }
        mock_scan_api.return_value = {
            "status": "success",
            "vulnerabilities": [{"title": "API Vulnerability"}],
            "summary": {"total_vulnerabilities": 1}
        }
        mock_scan_auth.return_value = {
            "status": "success",
            "vulnerabilities": [{"title": "Auth Vulnerability"}],
            "summary": {"total_vulnerabilities": 1}
        }
        
        results = self.scanner.comprehensive_scan(
            url=self.test_url,
            endpoints=self.test_endpoints
        )
        
        assert results["status"] == "success"
        assert results["url"] == self.test_url
        assert len(results["vulnerabilities"]) == 3
        assert results["summary"]["total_vulnerabilities"] == 3
        
        mock_scan_web.assert_called_once()
        assert mock_scan_api.call_count == len(self.test_endpoints)
        mock_scan_auth.assert_called_once()
