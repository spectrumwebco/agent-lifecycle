"""
Vulnerability scanning tools for security review.
"""

import logging
import re
from typing import Dict, List, Any, Optional

logger = logging.getLogger(__name__)

class VulnerabilityScanner:
    """
    Scans code for common security vulnerabilities.
    """
    
    def __init__(self):
        """Initialize the vulnerability scanner."""
        self.vulnerabilities = []
    
    def scan(self, repository: str, branch: str, files: List[Dict[str, Any]], scan_depth: str = "standard") -> List[Dict[str, Any]]:
        """
        Scan code for vulnerabilities.
        
        Args:
            repository: Repository name
            branch: Branch name
            files: List of files to scan
            scan_depth: Depth of the scan (basic, standard, deep)
            
        Returns:
            List of identified vulnerabilities
        """
        self.vulnerabilities = []
        
        depth_multiplier = {
            "basic": 0.5,
            "standard": 1.0,
            "deep": 2.0
        }.get(scan_depth, 1.0)
        
        for file_info in files:
            file_path = file_info.get("path", "")
            content = file_info.get("content", "")
            language = self._detect_language(file_path)
            
            if not content or self._is_binary(content):
                continue
                
            logger.info("Scanning file %s with language %s", file_path, language)
            
            if language == "python":
                self._scan_python_code(content, file_path, depth_multiplier)
            elif language == "javascript" or language == "typescript":
                self._scan_js_code(content, file_path, depth_multiplier)
            elif language == "go":
                self._scan_go_code(content, file_path, depth_multiplier)
            elif language == "c" or language == "cpp":
                self._scan_c_code(content, file_path, depth_multiplier)
            else:
                self._scan_generic_code(content, file_path, depth_multiplier)
        
        return self.vulnerabilities
    
    def _detect_language(self, file_path: str) -> str:
        """Detect the programming language based on file extension."""
        if file_path.endswith(".py"):
            return "python"
        elif file_path.endswith(".js"):
            return "javascript"
        elif file_path.endswith(".ts"):
            return "typescript"
        elif file_path.endswith(".go"):
            return "go"
        elif file_path.endswith(".c") or file_path.endswith(".h"):
            return "c"
        elif file_path.endswith(".cpp") or file_path.endswith(".hpp"):
            return "cpp"
        elif file_path.endswith(".java"):
            return "java"
        elif file_path.endswith(".rb"):
            return "ruby"
        elif file_path.endswith(".php"):
            return "php"
        else:
            return "unknown"
    
    def _is_binary(self, content: str) -> bool:
        """Check if content appears to be binary."""
        return '\0' in content or sum(1 for c in content if ord(c) < 32 and c not in '\n\r\t') > len(content) * 0.1
    
    def _scan_python_code(self, content: str, file_path: str, depth_multiplier: float) -> None:
        """Scan Python code for vulnerabilities."""
        if re.search(r'execute\(\s*[f"\']+.*?\{.*?\}.*?["\']+\s*\)', content) or \
           re.search(r'execute\(\s*["\']+.*?\%s.*?["\']+\s*%\s*\(.*?\)', content):
            self.vulnerabilities.append({
                "type": "sql_injection",
                "file": file_path,
                "description": "Potential SQL injection vulnerability detected",
                "severity": "critical"
            })
        
        if re.search(r'os\.system\(\s*[f"\']+.*?\{.*?\}.*?["\']+\s*\)', content) or \
           re.search(r'subprocess\.(?:call|Popen|run)\(\s*[f"\']+.*?\{.*?\}.*?["\']+\s*\)', content):
            self.vulnerabilities.append({
                "type": "command_injection",
                "file": file_path,
                "description": "Potential command injection vulnerability detected",
                "severity": "critical"
            })
        
        if re.search(r'pickle\.loads', content) or re.search(r'yaml\.load\s*\(', content) or \
           re.search(r'eval\s*\(', content):
            self.vulnerabilities.append({
                "type": "insecure_deserialization",
                "file": file_path,
                "description": "Potential insecure deserialization vulnerability detected",
                "severity": "high"
            })
        
        if depth_multiplier > 1.0:
            if re.search(r'DEBUG\s*=\s*True', content) or re.search(r'DEVELOPMENT_MODE\s*=\s*True', content):
                self.vulnerabilities.append({
                    "type": "debug_enabled",
                    "file": file_path,
                    "description": "Debug or development mode settings detected",
                    "severity": "medium"
                })
            
            if re.search(r'password\s*=\s*["\'][^"\']+["\']', content) or \
               re.search(r'secret\s*=\s*["\'][^"\']+["\']', content) or \
               re.search(r'api_key\s*=\s*["\'][^"\']+["\']', content):
                self.vulnerabilities.append({
                    "type": "hardcoded_credentials",
                    "file": file_path,
                    "description": "Hardcoded credentials detected",
                    "severity": "high"
                })
    
    def _scan_js_code(self, content: str, file_path: str, depth_multiplier: float) -> None:
        """Scan JavaScript/TypeScript code for vulnerabilities."""
        if re.search(r'innerHTML\s*=', content) or re.search(r'document\.write\(', content):
            self.vulnerabilities.append({
                "type": "xss",
                "file": file_path,
                "description": "Potential XSS vulnerability detected",
                "severity": "high"
            })
        
        if re.search(r'Object\.assign\(\s*{}\s*,', content) or \
           re.search(r'\.prototype\s*=', content):
            self.vulnerabilities.append({
                "type": "prototype_pollution",
                "file": file_path,
                "description": "Potential prototype pollution vulnerability detected",
                "severity": "medium"
            })
        
        if re.search(r'eval\s*\(', content) or re.search(r'new Function\s*\(', content):
            self.vulnerabilities.append({
                "type": "eval_usage",
                "file": file_path,
                "description": "Use of eval() or new Function() detected, which can lead to code injection",
                "severity": "high"
            })
        
        if depth_multiplier > 1.0:
            if re.search(r'password\s*[:=]\s*["\'][^"\']+["\']', content) or \
               re.search(r'apiKey\s*[:=]\s*["\'][^"\']+["\']', content):
                self.vulnerabilities.append({
                    "type": "hardcoded_credentials",
                    "file": file_path,
                    "description": "Hardcoded credentials detected",
                    "severity": "high"
                })
    
    def _scan_go_code(self, content: str, file_path: str, depth_multiplier: float) -> None:
        """Scan Go code for vulnerabilities."""
        if re.search(r'db\.Query\(\s*["`].*?\$\{.*?\}.*?["`]\s*,', content) or \
           re.search(r'db\.Exec\(\s*["`].*?\$\{.*?\}.*?["`]\s*,', content):
            self.vulnerabilities.append({
                "type": "sql_injection",
                "file": file_path,
                "description": "Potential SQL injection vulnerability detected",
                "severity": "critical"
            })
        
        if re.search(r'exec\.Command\(\s*["`].*?\$\{.*?\}.*?["`]\s*\)', content):
            self.vulnerabilities.append({
                "type": "command_injection",
                "file": file_path,
                "description": "Potential command injection vulnerability detected",
                "severity": "critical"
            })
        
        if depth_multiplier > 1.0:
            if re.search(r'crypto/md5', content) or re.search(r'crypto/sha1', content):
                self.vulnerabilities.append({
                    "type": "insecure_crypto",
                    "file": file_path,
                    "description": "Use of insecure cryptographic algorithms detected",
                    "severity": "medium"
                })
    
    def _scan_c_code(self, content: str, file_path: str, depth_multiplier: float) -> None:
        """Scan C/C++ code for vulnerabilities."""
        if re.search(r'strcpy\s*\(', content) or re.search(r'strcat\s*\(', content) or \
           re.search(r'gets\s*\(', content):
            self.vulnerabilities.append({
                "type": "buffer_overflow",
                "file": file_path,
                "description": "Use of unsafe functions that can lead to buffer overflow",
                "severity": "critical"
            })
        
        if re.search(r'printf\s*\(\s*[^,)]+\s*\)', content) or \
           re.search(r'fprintf\s*\(\s*[^,)]+\s*,\s*[^,)]+\s*\)', content):
            self.vulnerabilities.append({
                "type": "format_string",
                "file": file_path,
                "description": "Potential format string vulnerability detected",
                "severity": "high"
            })
        
        if depth_multiplier > 1.0:
            if re.search(r'free\s*\(\s*\w+\s*\)', content) and \
               re.search(r'\w+\s*->\s*\w+', content):
                self.vulnerabilities.append({
                    "type": "use_after_free",
                    "file": file_path,
                    "description": "Potential use-after-free vulnerability detected",
                    "severity": "high"
                })
    
    def _scan_generic_code(self, content: str, file_path: str, depth_multiplier: float) -> None:
        """Scan generic code for vulnerabilities."""
        if re.search(r'password\s*[=:]\s*["\'][^"\']+["\']', content) or \
           re.search(r'apikey\s*[=:]\s*["\'][^"\']+["\']', content) or \
           re.search(r'secret\s*[=:]\s*["\'][^"\']+["\']', content):
            self.vulnerabilities.append({
                "type": "hardcoded_credentials",
                "file": file_path,
                "description": "Hardcoded credentials detected",
                "severity": "high"
            })
